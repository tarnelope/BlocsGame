package com.bloc.blocs;

import org.andengine.engine.camera.Camera;
import org.andengine.engine.handler.IUpdateHandler;
import org.andengine.entity.Entity;
import org.andengine.entity.primitive.Rectangle;
import org.andengine.entity.scene.Scene;
import org.andengine.entity.scene.background.Background;
import org.andengine.entity.shape.Shape;
import org.andengine.entity.sprite.Sprite;
import org.andengine.extension.physics.box2d.PhysicsFactory;
import org.andengine.extension.physics.box2d.PhysicsWorld;

import android.util.Log;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.FixtureDef;



public class PlayScene extends Scene {
	
	Camera mCamera;
	final public GamePiece gamePiece;
	
	public PhysicsWorld physicsWorld;
	
	public Entity grid;
	
	Sprite tile;

	public PlayScene() {
		setBackground(new Background(0.1f, 0.6f, 0.134f));
		mCamera = Blocs.getSharedInstance().mCamera;
		
		TetrisBoard board = new TetrisBoard(this);
		final Rectangle ground = new Rectangle(board.LEFT_X, board.BOTTOM_Y+board.TILE_DIMEN, board.BOARD_WIDTH, 2, Blocs.getSharedInstance().getVertexBufferObjectManager());
		ground.setColor(0f, 0f, 0f);
		
		gamePiece = new GamePiece();
		tile = new Sprite(200, 200, Blocs.getSharedInstance().cyanTile, Blocs.getSharedInstance().getVertexBufferObjectManager());
		
		
		attachChild(gamePiece);
		
		attachChild(tile);
		attachChild(ground);
		
		registerUpdateHandler(new IUpdateHandler() {
			
			@Override
			public void reset() {
				// TODO Auto-generated method stub
				
			}
			
			@Override
			public void onUpdate(float pSecondsElapsed) {
				if (tile.collidesWith(ground)) {
					Log.d("PlayScene", "piece touched ground");
				}
				
				
				
				
				
			}
		});
		
		Blocs.getSharedInstance().setCurrentScene(this);
		
	}
	
	public static Body createHexagonBody(final PhysicsWorld pPhysicsWorld, final Shape pShape, final BodyType pBodyType, final FixtureDef pFixtureDef) {
        /* Remember that the vertices are relative to the center-coordinates of the Shape. */
        final float halfWidth = pShape.getWidth() * 0.5f / PIXEL_TO_METER_RATIO_DEFAULT;
        final float halfHeight = pShape.getHeightScaled() * 0.5f / PIXEL_TO_METER_RATIO_DEFAULT;
 
        /* The top and bottom vertex of the hexagon are on the bottom and top of hexagon-sprite. */
        final float top = -halfHeight;
        final float bottom = halfHeight;
 
        final float centerX = 0;
 
        /* The left and right vertices of the heaxgon are not on the edge of the hexagon-sprite, so we need to inset them a little. */
        final float left = -halfWidth + 2.5f / PIXEL_TO_METER_RATIO_DEFAULT;
        final float right = halfWidth - 2.5f / PIXEL_TO_METER_RATIO_DEFAULT;
        final float higher = top + 8.25f / PIXEL_TO_METER_RATIO_DEFAULT;
        final float lower = bottom - 8.25f / PIXEL_TO_METER_RATIO_DEFAULT;
 
        final Vector2[] vertices = {
                        new Vector2(centerX, top),
                        new Vector2(right, higher),
                        new Vector2(right, lower),
                        new Vector2(centerX, bottom),
                        new Vector2(left, lower),
                        new Vector2(left, higher)
        };
 
        return PhysicsFactory.createPolygonBody(pPhysicsWorld, pShape, vertices, pBodyType, pFixtureDef);
}
	
	/*private Entity boundedGrid() {
		Entity playGrid = new Entity(0, 0);
		
//x, y, width, height
		final Rectangle ground = new Rectangle(LEFT_X, BOTTOM_Y, BOARD_WIDTH, 2, Blocs.getSharedInstance().getVertexBufferObjectManager());
		final Rectangle left = new Rectangle(LEFT_X, TOP_Y, 2, BOARD_HEIGHT, Blocs.getSharedInstance().getVertexBufferObjectManager());
		final Rectangle right = new Rectangle(RIGHT_X, TOP_Y, 2, BOARD_HEIGHT, Blocs.getSharedInstance().getVertexBufferObjectManager());
		
		playGrid.attachChild(right);
		playGrid.attachChild(left);
		playGrid.attachChild(ground);
		
		return grid;
	}
	
	public Entity getGridInstance() {
		if (grid == null) {
			grid = boundedGrid();
		} 
		return grid;
	} */
	
}
