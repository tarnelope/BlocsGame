package com.bloc.blocs;

import static org.andengine.extension.physics.box2d.util.constants.PhysicsConstants.PIXEL_TO_METER_RATIO_DEFAULT;
import org.andengine.engine.camera.Camera;
import org.andengine.engine.handler.IUpdateHandler;
import org.andengine.entity.Entity;
import org.andengine.entity.primitive.Rectangle;
import org.andengine.entity.scene.Scene;
import org.andengine.entity.scene.background.Background;
import org.andengine.entity.shape.IShape;
import org.andengine.entity.sprite.AnimatedSprite;
import org.andengine.entity.sprite.Sprite;
import org.andengine.extension.physics.box2d.PhysicsConnector;
import org.andengine.extension.physics.box2d.PhysicsWorld;

import android.util.Log;

import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.Body;
import com.badlogic.gdx.physics.box2d.BodyDef;
import com.badlogic.gdx.physics.box2d.BodyDef.BodyType;
import com.badlogic.gdx.physics.box2d.FixtureDef;
import com.badlogic.gdx.physics.box2d.PolygonShape;



public class PlayScene extends Scene {
	
	Camera mCamera;
	final public GamePiece gamePiece;
	
	public PhysicsWorld physicsWorld;
	
	public Entity grid;
	
	Sprite tile;

	public PlayScene() {
		
		final FixtureDef wallFixtureDef = PhysicsFactory.createFixtureDef(0, 0.5f, 0.5f);
		
		setBackground(new Background(0.1f, 0.6f, 0.134f));
		mCamera = Blocs.getSharedInstance().mCamera;
		
		TetrisBoard board = new TetrisBoard(this);
		final Rectangle ground = new Rectangle(board.LEFT_X, board.BOTTOM_Y+board.TILE_DIMEN, board.BOARD_WIDTH, 2, Blocs.getSharedInstance().getVertexBufferObjectManager());
		ground.setColor(0f, 0f, 0f);
		
		gamePiece = new GamePiece();
		tile = new Sprite(200, 200, Blocs.getSharedInstance().cyanTile, Blocs.getSharedInstance().getVertexBufferObjectManager());
		
		Body mBody = createBoxBody(physicsWorld, ground, BodyType.StaticBody, wallFixtureDef, PIXEL_TO_METER_RATIO_DEFAULT);
		
		attachChild(gamePiece.piece);
		
		attachChild(tile);
		attachChild(ground);
		
		registerUpdateHandler(new IUpdateHandler() {
			
			@Override
			public void reset() {
				// TODO Auto-generated method stub
				
			}
			
			@Override
			public void onUpdate(float pSecondsElapsed) {
				if (tile.collidesWith(ground)) {
					Log.d("PlayScene", "piece touched ground");
				}
				
			}
		});
		
		Blocs.getSharedInstance().setCurrentScene(this);
	}
	
	BodyType pBodyType = BodyType.StaticBody;
	FixtureDef pFixtureDef = new FixtureDef();
	
	public static Body createBoxBody(final PhysicsWorld pPhysicsWorld, final IShape pShape, final BodyType pBodyType, final FixtureDef pFixtureDef, final float pPixelToMeterRatio) { {

		final BodyDef mBodyDef = new BodyDef();
	    mBodyDef.type = pBodyType;
	    mBodyDef.position.x = 1;
	    mBodyDef.position.y = 1;
	    final Body mBody = pPhysicsWorld.createBody(mBodyDef);
	
	    final PolygonShape mPoly = new PolygonShape();
	    
	    Vector2[] pVertices = {
	            new Vector2(-20,62),
	            new Vector2(20,62),
	            new Vector2(20,20),
	            new Vector2(-20,20),
	    };
	    
	    // YOU'LL NEED TO ADD CODE TO ESTABLISH YOUR VERTICES AS A VECTOR2 ARRAY Vector2[] pVertices
	    // THE COORDINATES OF YOUR VERTICES DETERMINE WHERE ON THE BODY THIS POLYGON SHAPE WILL APPEAR
	    // DO ALL OF THAT BEFORE CALLING THIS NEXT LINE
	
	    mPoly.set(pVertices);
	    pFixtureDef.shape = mPoly;
	    mBody.createFixture(pFixtureDef);
	    mPoly.dispose();
	
	    // NOW WE CREATE MORE SHAPES TO ATTACH TO THE BODY
	    // ESSENTIALLY WE ARE BUILDING SOMETHING LIKE A TREE OR A MOUNTAIN BY ADDING LOTS OF SHAPES TO A SINGLE BODY
	   
	    final PolygonShape mPoly2 = new PolygonShape();
	
	    Vector2[] pVertices2 = {
                new Vector2(20,20),
                new Vector2(62,20),
                new Vector2(62,-20),
                new Vector2(20,-20),
        };
	    
	    // NOW FOR THIS SHAPE YOU WANT TO OFFSET THE COORDINATES OF A NEW SET OF VERTICES Vector2[] pVertices2
	    // AGAIN YOU'LL HAVE TO DO THAT PART YOURSELF BEFORE CALLING THE NEXT LINE
	    // THEN THIS SHAPE WILL APPEAR ON A DIFFERENT PART OF THE BODY
	
	    mPoly2.set(pVertices2);
	    pFixtureDef.shape = mPoly2;
	    mBody.createFixture(pFixtureDef);
	    mPoly2.dispose();
	
	    return mBody;
	    // WE CAN REPEAT THE ABOVE AND ADD EVEN MORE SHAPES TO THE BODY IF WE WANT
	   
	    // NOW WE ATTACH A GRAPHIC TO COVER THE ENTIRE THING
	/*
	    AnimatedSprite mSprite = new AnimatedSprite(mX, mY, this.mTextureRegion);
	    this.mPhysicsWorld.registerPhysicsConnector(new PhysicsConnector(mSprite, mBody, true, true));
	    this.mScene.attachChild(mSprite);*/
		}
	}
	/*private Entity boundedGrid() {
		Entity playGrid = new Entity(0, 0);
		
//x, y, width, height
		final Rectangle ground = new Rectangle(LEFT_X, BOTTOM_Y, BOARD_WIDTH, 2, Blocs.getSharedInstance().getVertexBufferObjectManager());
		final Rectangle left = new Rectangle(LEFT_X, TOP_Y, 2, BOARD_HEIGHT, Blocs.getSharedInstance().getVertexBufferObjectManager());
		final Rectangle right = new Rectangle(RIGHT_X, TOP_Y, 2, BOARD_HEIGHT, Blocs.getSharedInstance().getVertexBufferObjectManager());
		
		playGrid.attachChild(right);
		playGrid.attachChild(left);
		playGrid.attachChild(ground);
		
		return grid;
	}
	
	public Entity getGridInstance() {
		if (grid == null) {
			grid = boundedGrid();
		} 
		return grid;
	} */
	
	
}
